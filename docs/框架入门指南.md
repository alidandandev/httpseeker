# HttpSeeker 框架入门指南

## 目录

1. [框架简介](#框架简介)
2. [核心特性](#核心特性)
3. [快速开始](#快速开始)
4. [项目结构](#项目结构)
5. [核心概念](#核心概念)
6. [测试用例编写](#测试用例编写)
7. [数据驱动测试](#数据驱动测试)
8. [高级功能](#高级功能)
9. [最佳实践](#最佳实践)
10. [常见问题](#常见问题)

---

## 框架简介

HttpSeeker 是一个基于 HTTP 请求的快速数据驱动 pytest 接口自动化测试框架。它通过 YAML/JSON 配置文件来定义测试用例，实现了测试数据与测试代码的完全分离，让测试人员能够专注于测试场景设计，而无需编写大量的测试代码。

### 技术栈

- **测试框架**: pytest
- **HTTP 客户端**: requests / httpx（支持双引擎）
- **数据解析**: pydantic（数据验证）
- **断言增强**: jsonpath、jsonschema、正则表达式
- **测试报告**: allure、pytest-html
- **日志系统**: loguru
- **数据库支持**: MySQL、Redis

---

## 核心特性

### 1. 数据驱动架构
- 使用 YAML/JSON 文件定义测试用例
- 测试数据与测试代码完全分离
- 支持参数化和数据模板

### 2. 多环境支持
- 灵活的环境配置管理（dev、test、pro）
- 动态环境变量替换
- 环境隔离机制

### 3. 丰富的断言方式
- **JSON 断言**: 基于 jsonpath 的响应断言
- **SQL 断言**: 数据库查询结果断言
- **JSON Schema 断言**: 响应结构验证
- **正则断言**: 基于正则表达式的匹配
- **Code 断言**: 类似 pytest 的原生断言

### 4. 请求增强
- 前置/后置处理（setup/teardown）
- 数据提取与变量缓存
- 接口依赖管理
- 钩子函数支持
- 请求/响应加密解密

### 5. 自动化能力
- 测试用例自动生成
- 测试报告自动生成（HTML/Allure）
- 测试结果通知（飞书、钉钉、企业微信、邮箱）

---

## 快速开始

### 1. 安装依赖

```bash
# 使用 pdm（推荐）
pdm install

# 或使用 pip
pip install -r requirements.txt
```

### 2. 项目初始化

项目目录结构：
```
HttpSeek/
├── httpseeker/                # 框架核心代码
│   ├── core/                  # 核心配置
│   │   ├── run_env/          # 环境配置目录
│   │   │   ├── dev.env       # 开发环境
│   │   │   ├── test.env      # 测试环境
│   │   │   └── pro.env       # 生产环境
│   │   ├── conf.toml         # 框架配置文件
│   │   └── hooks.py          # 自定义钩子函数
│   ├── data/                  # 测试数据目录
│   │   └── test_data/        # 测试用例数据
│   │       └── {project}/    # 项目名称
│   └── testcases/            # 测试用例目录
│       └── {project}/        # 项目名称
├── docs/                      # 文档目录
├── pyproject.toml            # 项目配置
└── README.md                 # 项目说明
```

### 3. 配置环境变量

在 `httpseeker/core/run_env/` 目录下创建或编辑环境文件：

**test.env 示例：**
```env
HOST=https://api.example.com
API_KEY=your_api_key
USERNAME=test_user
PASSWORD=test_password
```

### 4. 创建第一个测试用例

#### 步骤 1: 创建测试数据文件

在 `httpseeker/data/test_data/your_project/` 目录下创建 `test_login.yaml`：

```yaml
config:
  allure:
    epic: "用户系统"
    feature: "登录功能"
    story: "用户登录"
    severity: "critical"

  request:
    env: "test.env"
    headers:
      Content-Type: "application/json"
    timeout: 30
    verify: false

  module: "login"

test_steps:
  - name: "用户登录成功"
    case_id: "login_001"
    description: "验证用户使用正确的用户名和密码登录成功"

    request:
      method: "POST"
      url: "/api/v1/login"
      params: null
      headers: null
      cookies: null
      body_type: "json"
      body:
        username: "test_user"
        password: "test_password"
      files: null

    teardown:
      - assert:
          check: "验证状态码为200"
          type: "eq"
          value: 200
          jsonpath: "$.status_code"

      - assert:
          check: "验证登录成功"
          type: "eq"
          value: "success"
          jsonpath: "$.json.status"

      - extract:
          key: "token"
          type: "cache"
          jsonpath: "$.json.data.token"
```

#### 步骤 2: 生成测试用例代码

框架提供自动生成测试用例的功能：

```bash
# 在项目根目录执行
python -m httpseeker.cli generate
```

这将在 `httpseeker/testcases/your_project/` 目录下自动生成 `test_login.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import pytest

from httpseeker.common.send_request import send_request
from httpseeker.utils.request.case_data_parse import get_testcase_data

ddt_data, ids = get_testcase_data(filename='test_login.yaml')


class TestLogin:
    """Login"""

    @pytest.mark.parametrize('case_data', ddt_data, ids=ids)
    def test_login(self, case_data):
        """test_login"""
        send_request.send_request(case_data)
```

#### 步骤 3: 运行测试

```bash
# 使用框架 CLI 运行测试（推荐）
python -m httpseeker.cli --run

# 指定自定义配置文件
python -m httpseeker.cli --run --env prod.env --conf /path/to/conf.toml --auth /path/to/auth.yaml

# 使用 pytest 直接运行
pytest httpseeker/testcases/

# 运行特定项目的测试
pytest httpseeker/testcases/your_project/

# 运行特定测试文件
pytest httpseeker/testcases/your_project/test_login.py

# 生成 allure 报告
pytest httpseeker/testcases/ --alluredir=./httpseeker/report/allure_report
allure serve ./httpseeker/report/allure_report
```

---

## 项目结构

### 核心目录说明

```
httpseeker/
├── common/                    # 公共模块
│   ├── env_handler.py        # 环境变量处理
│   ├── log.py                # 日志系统
│   ├── send_request.py       # 请求发送核心逻辑
│   ├── variable_cache.py     # 变量缓存管理
│   └── yaml_handler.py       # YAML 文件处理
│
├── core/                      # 核心配置
│   ├── run_env/              # 运行环境配置
│   ├── allure_env/           # Allure 环境配置
│   ├── conf.toml             # 框架配置文件
│   ├── get_conf.py           # 配置读取
│   ├── hooks.py              # 钩子函数
│   └── path_conf.py          # 路径配置
│
├── data/                      # 测试数据
│   └── test_data/            # 测试用例数据文件
│
├── db/                        # 数据库模块
│   ├── mysql.py              # MySQL 客户端
│   └── redis.py              # Redis 客户端
│
├── enums/                     # 枚举类型
│   ├── assert_type.py        # 断言类型
│   ├── request/              # 请求相关枚举
│   │   ├── method.py         # HTTP 方法
│   │   ├── body.py           # 请求体类型
│   │   └── engin.py          # 请求引擎
│   └── ...
│
├── schemas/                   # 数据模型
│   └── case_data.py          # 测试用例数据模型（Pydantic）
│
├── testcases/                 # 测试用例
│   └── {project}/            # 项目测试用例
│
├── utils/                     # 工具模块
│   ├── allure_control.py     # Allure 报告控制
│   ├── assert_control.py     # 断言控制
│   ├── case_auto_generator.py # 测试用例自动生成
│   ├── encryption_filter.py  # 加密解密
│   ├── jsonpath_extractor.py # JSONPath 提取
│   └── ...
│
├── log/                       # 日志文件
├── report/                    # 测试报告
│   ├── allure_report/        # Allure 报告
│   └── html_report/          # HTML 报告
│
├── conftest.py               # pytest 配置
└── run.py                    # 运行入口
```

---

## 核心概念

### 1. 测试用例数据结构

测试用例数据文件由两部分组成：

#### config（配置部分）

定义测试用例的全局配置：

```yaml
config:
  # Allure 报告配置
  allure:
    epic: "业务线"           # 史诗
    feature: "功能模块"      # 特性
    story: "用户故事"        # 故事
    severity: "critical"     # 优先级: blocker/critical/normal/minor/trivial

  # 请求配置
  request:
    env: "test.env"          # 环境配置文件
    headers:                 # 全局请求头
      Content-Type: "application/json"
    timeout: 30              # 超时时间（秒）
    verify: false            # SSL 验证
    redirects: true          # 是否跟随重定向
    encryption_enabled: false # 是否启用加密
    encryption_key: null     # 加密密钥

  module: "module_name"      # 模块名称
  mark: ["smoke", "P0"]      # pytest 标记
```

#### test_steps（测试步骤）

定义具体的测试步骤：

```yaml
test_steps:
  - name: "测试步骤名称"
    case_id: "唯一用例ID"
    description: "用例描述"
    is_run: true              # 是否执行
    mark: ["smoke"]           # pytest 标记
    retry: 3                  # 重试次数

    # 请求配置
    request:
      method: "POST"          # GET/POST/PUT/DELETE/PATCH
      url: "/api/endpoint"    # 接口路径
      params: null            # URL 参数
      headers: null           # 请求头（覆盖全局）
      cookies: null           # Cookies
      body_type: "json"       # form/x_form/binary/json/text/xml
      body: {}                # 请求体
      files: null             # 文件上传

    # 前置处理
    setup:
      - testcase: "依赖用例ID"
      - sql: "SELECT * FROM users"
      - hook: "custom_function"
      - wait_time: 2

    # 后置处理
    teardown:
      - extract:              # 提取数据
          key: "token"
          type: "cache"       # cache/env/global
          jsonpath: "$.data.token"

      - assert:               # 断言
          check: "断言说明"
          type: "eq"
          value: 200
          jsonpath: "$.status_code"

      - sql: "UPDATE users SET status=1"
      - hook: "cleanup_function"
      - wait_time: 1
```

### 2. 变量系统

框架支持三种变量类型：

#### 环境变量（env）

在 `.env` 文件中定义，用 `${var_name}` 引用：

```yaml
request:
  url: "${HOST}/api/users"
  body:
    username: "${USERNAME}"
```

#### 缓存变量（cache）

临时变量，在测试会话中共享：

```yaml
# 提取到缓存
teardown:
  - extract:
      key: "user_id"
      type: "cache"
      jsonpath: "$.data.id"

# 使用缓存变量
request:
  url: "/api/users/${cache.user_id}"
```

#### 全局变量（global）

持久化变量，写入环境文件：

```yaml
teardown:
  - extract:
      key: "token"
      type: "global"
      jsonpath: "$.data.token"
```

### 3. 数据提取

使用 JSONPath 从响应中提取数据：

```yaml
teardown:
  - extract:
      key: "token"              # 变量名
      type: "cache"             # 变量类型
      jsonpath: "$.json.data.token"  # 提取路径
```

**可用的 JSONPath 根路径：**
- `$.status_code` - HTTP 状态码
- `$.json` - 响应 JSON 数据
- `$.headers` - 响应头
- `$.cookies` - Cookies
- `$.text` - 响应文本
- `$.elapsed` - 请求耗时

---

## 测试用例编写

### 基础用例示例

#### GET 请求示例

```yaml
config:
  allure:
    epic: "电商系统"
    feature: "商品管理"
    story: "查询商品列表"
    severity: "normal"

  request:
    env: "test.env"
    headers:
      Content-Type: "application/json"

  module: "product"

test_steps:
  - name: "获取商品列表"
    case_id: "product_001"
    description: "验证获取商品列表接口返回正确"

    request:
      method: "GET"
      url: "/api/v1/products"
      params:
        page: 1
        size: 10
        category: "electronics"
      headers: null
      cookies: null
      body_type: null
      body: null
      files: null

    teardown:
      - assert:
          check: "验证状态码"
          type: "eq"
          value: 200
          jsonpath: "$.status_code"

      - assert:
          check: "验证返回数据是列表"
          type: "contains"
          value: "data"
          jsonpath: "$.json"
```

#### POST 请求示例

```yaml
test_steps:
  - name: "创建商品"
    case_id: "product_002"
    description: "验证创建商品接口功能"

    request:
      method: "POST"
      url: "/api/v1/products"
      params: null
      headers:
        Authorization: "Bearer ${cache.token}"
      cookies: null
      body_type: "json"
      body:
        name: "iPhone 15 Pro"
        price: 7999
        stock: 100
        category: "electronics"
      files: null

    teardown:
      - assert:
          check: "验证创建成功"
          type: "eq"
          value: 201
          jsonpath: "$.status_code"

      - extract:
          key: "product_id"
          type: "cache"
          jsonpath: "$.json.data.id"
```

#### 文件上传示例

```yaml
test_steps:
  - name: "上传商品图片"
    case_id: "product_003"
    description: "验证商品图片上传功能"

    request:
      method: "POST"
      url: "/api/v1/products/${cache.product_id}/images"
      params: null
      headers:
        Authorization: "Bearer ${cache.token}"
      cookies: null
      body_type: "form"
      body:
        description: "商品主图"
      files:
        image: "/path/to/image.jpg"

    teardown:
      - assert:
          check: "验证上传成功"
          type: "eq"
          value: 200
          jsonpath: "$.status_code"
```

### 接口依赖处理

#### 场景 1: 单个依赖用例

```yaml
test_steps:
  # 用例1: 登录
  - name: "用户登录"
    case_id: "auth_001"
    request:
      method: "POST"
      url: "/api/v1/login"
      body_type: "json"
      body:
        username: "${USERNAME}"
        password: "${PASSWORD}"

    teardown:
      - extract:
          key: "token"
          type: "cache"
          jsonpath: "$.json.data.token"

  # 用例2: 获取用户信息（依赖登录）
  - name: "获取用户信息"
    case_id: "user_001"

    setup:
      - testcase: "auth_001"  # 先执行登录用例

    request:
      method: "GET"
      url: "/api/v1/user/profile"
      headers:
        Authorization: "Bearer ${cache.token}"
```

#### 场景 2: 复杂依赖链

```yaml
test_steps:
  # 用例1: 登录
  - name: "用户登录"
    case_id: "auth_001"
    request:
      method: "POST"
      url: "/api/v1/login"
      body_type: "json"
      body:
        username: "${USERNAME}"
        password: "${PASSWORD}"
    teardown:
      - extract:
          key: "token"
          type: "cache"
          jsonpath: "$.json.data.token"

  # 用例2: 创建订单（依赖登录）
  - name: "创建订单"
    case_id: "order_001"

    setup:
      - testcase: "auth_001"

    request:
      method: "POST"
      url: "/api/v1/orders"
      headers:
        Authorization: "Bearer ${cache.token}"
      body_type: "json"
      body:
        product_id: 123
        quantity: 2

    teardown:
      - extract:
          key: "order_id"
          type: "cache"
          jsonpath: "$.json.data.order_id"

  # 用例3: 支付订单（依赖创建订单）
  - name: "支付订单"
    case_id: "payment_001"

    setup:
      - testcase: "order_001"  # 会自动执行 auth_001

    request:
      method: "POST"
      url: "/api/v1/orders/${cache.order_id}/pay"
      headers:
        Authorization: "Bearer ${cache.token}"
      body_type: "json"
      body:
        payment_method: "alipay"
```

---

## 数据驱动测试

### 多用例数据驱动

在同一个 YAML 文件中定义多个测试步骤，框架会自动参数化：

```yaml
config:
  allure:
    epic: "用户系统"
    feature: "登录功能"
    story: "登录场景测试"
    severity: "critical"

  request:
    env: "test.env"

  module: "login"

test_steps:
  # 场景1: 正常登录
  - name: "正常登录"
    case_id: "login_001"
    request:
      method: "POST"
      url: "/api/v1/login"
      body_type: "json"
      body:
        username: "admin"
        password: "admin123"
    teardown:
      - assert:
          check: "验证登录成功"
          type: "eq"
          value: "success"
          jsonpath: "$.json.status"

  # 场景2: 用户名错误
  - name: "用户名错误"
    case_id: "login_002"
    request:
      method: "POST"
      url: "/api/v1/login"
      body_type: "json"
      body:
        username: "wrong_user"
        password: "admin123"
    teardown:
      - assert:
          check: "验证返回用户名错误"
          type: "eq"
          value: "用户名不存在"
          jsonpath: "$.json.message"

  # 场景3: 密码错误
  - name: "密码错误"
    case_id: "login_003"
    request:
      method: "POST"
      url: "/api/v1/login"
      body_type: "json"
      body:
        username: "admin"
        password: "wrong_password"
    teardown:
      - assert:
          check: "验证返回密码错误"
          type: "eq"
          value: "密码错误"
          jsonpath: "$.json.message"

  # 场景4: 空用户名
  - name: "空用户名"
    case_id: "login_004"
    request:
      method: "POST"
      url: "/api/v1/login"
      body_type: "json"
      body:
        username: ""
        password: "admin123"
    teardown:
      - assert:
          check: "验证参数校验"
          type: "eq"
          value: 400
          jsonpath: "$.status_code"
```

pytest 会自动将这 4 个场景参数化为 4 个独立的测试用例。

### 条件执行

使用 `is_run` 字段控制用例是否执行：

```yaml
test_steps:
  - name: "测试用例1"
    case_id: "test_001"
    is_run: true          # 执行
    request:
      # ...

  - name: "测试用例2"
    case_id: "test_002"
    is_run: false         # 跳过
    request:
      # ...

  - name: "测试用例3"
    case_id: "test_003"
    is_run:               # 条件执行
      env: "test.env"     # 仅在 test 环境执行
    request:
      # ...
```

---

## 高级功能

### 1. 断言详解

#### JSON 断言

基于 JSONPath 的响应断言：

```yaml
teardown:
  # 相等断言
  - assert:
      check: "验证状态码"
      type: "eq"              # 等于
      value: 200
      jsonpath: "$.status_code"

  # 不等断言
  - assert:
      check: "验证不为空"
      type: "not_eq"          # 不等于
      value: null
      jsonpath: "$.json.data"

  # 大小比较
  - assert:
      check: "验证价格大于0"
      type: "gt"              # 大于
      value: 0
      jsonpath: "$.json.data.price"

  - assert:
      check: "验证库存充足"
      type: "ge"              # 大于等于
      value: 10
      jsonpath: "$.json.data.stock"

  # 字符串断言
  - assert:
      check: "验证包含关键字"
      type: "contains"        # 包含
      value: "success"
      jsonpath: "$.json.message"

  - assert:
      check: "验证不包含错误"
      type: "not_contains"    # 不包含
      value: "error"
      jsonpath: "$.json.message"

  - assert:
      check: "验证以http开头"
      type: "startswith"      # 以...开头
      value: "http"
      jsonpath: "$.json.data.url"

  - assert:
      check: "验证以.jpg结尾"
      type: "endswith"        # 以...结尾
      value: ".jpg"
      jsonpath: "$.json.data.image"

  # 长度断言
  - assert:
      check: "验证手机号长度"
      type: "len_eq"          # 长度等于
      value: 11
      jsonpath: "$.json.data.phone"
```

**支持的断言类型：**
- `eq` - 等于
- `not_eq` - 不等于
- `gt` - 大于
- `ge` - 大于等于
- `lt` - 小于
- `le` - 小于等于
- `str_eq` - 字符串相等
- `len_eq` - 长度等于
- `not_len_eq` - 长度不等于
- `len_gt` - 长度大于
- `len_ge` - 长度大于等于
- `len_lt` - 长度小于
- `len_le` - 长度小于等于
- `contains` - 包含
- `not_contains` - 不包含
- `startswith` - 以...开头
- `endswith` - 以...结尾

#### SQL 断言

查询数据库进行断言：

```yaml
teardown:
  - assert:
      check: "验证用户已创建"
      type: "eq"
      value: "active"
      sql: "SELECT status FROM users WHERE id = 123"
      fetch: "one"          # one/all
      jsonpath: "$.status"
```

#### JSON Schema 断言

验证响应数据结构：

```yaml
teardown:
  - assert:
      check: "验证响应结构"
      type: "jsonschema"
      jsonschema:
        type: "object"
        required: ["code", "message", "data"]
        properties:
          code:
            type: "integer"
          message:
            type: "string"
          data:
            type: "object"
            properties:
              id:
                type: "integer"
              name:
                type: "string"
              email:
                type: "string"
                format: "email"
```

#### 正则断言

使用正则表达式验证：

```yaml
teardown:
  - assert:
      check: "验证手机号格式"
      type: "re"
      pattern: "^1[3-9]\\d{9}$"
      jsonpath: "$.json.data.phone"

  - assert:
      check: "验证邮箱格式"
      type: "re"
      pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
      jsonpath: "$.json.data.email"
```

#### Code 断言

类似 pytest 的原生断言：

```yaml
teardown:
  - assert: "assert 200 == pm.response.get('status_code')"

  - assert: "assert 'success' in pm.response.get('json').get('message')"

  - assert: "assert pm.response.get('json').get('data').get('id') > 0"
```

### 2. 数据库操作

#### Setup SQL（前置）

```yaml
setup:
  # 简单 SQL
  - sql: "DELETE FROM test_data WHERE test_id = '${TEST_ID}'"

  # 复杂 SQL（带数据提取）
  - sql:
      key: "user_count"
      type: "cache"
      sql: "SELECT COUNT(*) as count FROM users WHERE status = 'active'"
      fetch: "one"
      jsonpath: "$.count"
```

#### Teardown SQL（后置）

```yaml
teardown:
  # 数据清理
  - sql: "DELETE FROM orders WHERE created_at < NOW() - INTERVAL 7 DAY"

  # 数据验证
  - sql:
      key: "order_status"
      type: "cache"
      sql: "SELECT status FROM orders WHERE id = ${cache.order_id}"
      fetch: "one"
      jsonpath: "$.status"

  - assert:
      check: "验证订单状态"
      type: "eq"
      value: "paid"
      jsonpath: "$.cache.order_status"
```

### 3. 钩子函数

在 `httpseeker/core/hooks.py` 中定义自定义函数：

```python
import datetime
from faker import Faker

faker = Faker(locale='zh_CN')

def current_time() -> datetime.datetime:
    """获取当前时间"""
    return datetime.datetime.now()

def random_phone() -> str:
    """生成随机手机号"""
    return faker.phone_number()

def custom_data_generator(params: dict) -> dict:
    """自定义数据生成器"""
    return {
        "id": faker.uuid4(),
        "name": faker.name(),
        "email": faker.email(),
        "created_at": current_time().isoformat()
    }
```

在测试用例中使用：

```yaml
setup:
  - hook: "custom_data_generator"

request:
  body:
    phone: "${hook.random_phone()}"
    timestamp: "${hook.current_time()}"
```

### 4. 请求/响应加密

框架支持请求体加密和响应解密：

```yaml
config:
  request:
    env: "test.env"
    encryption_enabled: true          # 启用加密
    encryption_key: "your_secret_key" # 加密密钥

test_steps:
  - name: "加密登录请求"
    case_id: "login_001"

    request:
      method: "POST"
      url: "/api/v1/login"
      body_type: "json"
      body:
        username: "admin"
        password: "admin123"
      # body 会自动加密

    teardown:
      # 响应会自动解密
      - assert:
          type: "eq"
          value: "success"
          jsonpath: "$.json.status"
```

加密配置会自动添加以下请求头：
```
X-Encrypted: true
X-Encryption-Algorithm: AES-256-CBC
```

### 5. 重试机制

支持失败重试：

```yaml
test_steps:
  - name: "不稳定的接口"
    case_id: "test_001"
    retry: 3              # 失败时重试 3 次

    request:
      method: "GET"
      url: "/api/v1/unstable-endpoint"
```

也可以在 `conf.toml` 中配置全局重试：

```toml
[request]
retry = 3
```

---

## 最佳实践

### 1. 项目组织

#### 按业务模块组织

```
httpseeker/
├── data/test_data/
│   └── ecommerce/              # 项目名
│       ├── auth/               # 认证模块
│       │   ├── test_login.yaml
│       │   └── test_register.yaml
│       ├── product/            # 商品模块
│       │   ├── test_product_list.yaml
│       │   └── test_product_crud.yaml
│       └── order/              # 订单模块
│           ├── test_create_order.yaml
│           └── test_pay_order.yaml
│
└── testcases/
    └── ecommerce/
        ├── auth/
        ├── product/
        └── order/
```

### 2. 环境管理

#### 多环境配置

```bash
# 开发环境
httpseeker/core/run_env/dev.env
HOST=http://dev-api.example.com
DB_HOST=dev-db.example.com

# 测试环境
httpseeker/core/run_env/test.env
HOST=http://test-api.example.com
DB_HOST=test-db.example.com

# 生产环境
httpseeker/core/run_env/pro.env
HOST=https://api.example.com
DB_HOST=prod-db.example.com
```

#### 动态环境选择

**方法 1: 在测试用例中指定**

```yaml
config:
  request:
    env: "test.env"  # 指定使用测试环境
```

**方法 2: 通过 CLI 参数指定（推荐）**

```bash
# 指定环境变量文件
python -m httpseeker.cli --run --env prod.env

# 指定自定义配置文件
python -m httpseeker.cli --run --conf /path/to/custom_conf.toml

# 指定自定义认证文件
python -m httpseeker.cli --run --auth /path/to/custom_auth.yaml

# 同时指定多个配置
python -m httpseeker.cli --run --env prod.env --conf /path/to/conf.toml --auth /path/to/auth.yaml
```

**CLI 参数说明：**

| 参数 | 说明 | 示例 |
|------|------|------|
| `--env <ENV_FILE>` | 指定环境变量文件名，会覆盖 conf.toml 中的 global_env 配置 | `--env prod.env` |
| `--conf <CONF_FILE>` | 指定配置文件路径，默认使用 httpseeker/core/conf.toml | `--conf /custom/conf.toml` |
| `--auth <AUTH_FILE>` | 指定认证配置文件路径，默认使用 httpseeker/core/auth.yaml | `--auth /custom/auth.yaml` |

**使用场景：**

1. **多环境测试**：不同环境使用不同的 env 文件
   ```bash
   # 测试环境
   python -m httpseeker.cli --run --env test.env

   # 生产环境
   python -m httpseeker.cli --run --env prod.env
   ```

2. **多项目配置**：不同项目使用独立的配置文件
   ```bash
   python -m httpseeker.cli --run \
     --conf /projects/project_a/conf.toml \
     --auth /projects/project_a/auth.yaml
   ```

3. **CI/CD 集成**：在持续集成中动态指定配置
   ```bash
   python -m httpseeker.cli --run \
     --env ${ENV_FILE} \
     --conf ${CONF_PATH} \
     --auth ${AUTH_PATH}
   ```

### 3. 代码中使用自定义配置

除了通过 CLI 参数指定配置文件，也可以在代码中直接调用：

```python
from httpseeker.run import run

# 指定自定义配置
run(
    global_env='prod.env',
    conf_path='/path/to/conf.toml',
    auth_path='/path/to/auth.yaml'
)
```

这在编写自定义测试脚本或集成到其他系统时特别有用。

### 4. 变量命名规范

```yaml
# 推荐的命名方式
teardown:
  - extract:
      key: "user_token"          # 清晰表达变量含义
      type: "cache"
      jsonpath: "$.json.data.token"

  - extract:
      key: "order_id"
      type: "cache"
      jsonpath: "$.json.data.order_id"

# 避免
teardown:
  - extract:
      key: "token"               # 过于宽泛
      type: "cache"
      jsonpath: "$.json.data.token"

  - extract:
      key: "id"                  # 不明确
      type: "cache"
      jsonpath: "$.json.data.order_id"
```

### 5. 用例ID规范

使用有意义的用例ID：

```yaml
# 推荐格式: {module}_{business}_{sequence}
test_steps:
  - name: "用户登录"
    case_id: "auth_login_001"       # 认证模块-登录-序号001

  - name: "创建商品"
    case_id: "product_create_001"   # 商品模块-创建-序号001

  - name: "查询订单"
    case_id: "order_query_001"      # 订单模块-查询-序号001
```

### 6. 断言策略

#### 多层断言

```yaml
teardown:
  # 第1层：验证 HTTP 层
  - assert:
      check: "验证HTTP状态码"
      type: "eq"
      value: 200
      jsonpath: "$.status_code"

  # 第2层：验证业务状态
  - assert:
      check: "验证业务成功"
      type: "eq"
      value: "success"
      jsonpath: "$.json.status"

  # 第3层：验证业务数据
  - assert:
      check: "验证返回数据不为空"
      type: "not_eq"
      value: null
      jsonpath: "$.json.data"

  # 第4层：验证具体字段
  - assert:
      check: "验证用户ID存在"
      type: "gt"
      value: 0
      jsonpath: "$.json.data.user_id"
```

### 7. 测试数据管理

#### 使用环境变量管理测试数据

```env
# test.env
TEST_USER_ADMIN=admin
TEST_PASS_ADMIN=admin123
TEST_USER_NORMAL=testuser
TEST_PASS_NORMAL=test123
```

```yaml
request:
  body:
    username: "${TEST_USER_ADMIN}"
    password: "${TEST_PASS_ADMIN}"
```

#### 敏感数据处理

不要在 YAML 文件中硬编码敏感信息：

```yaml
# ❌ 错误示例
request:
  body:
    password: "admin123"
    api_key: "sk-1234567890abcdef"

# ✅ 正确示例
request:
  body:
    password: "${TEST_PASSWORD}"
    api_key: "${API_KEY}"
```

### 8. 日志和调试

#### 查看详细日志

日志文件位置：`httpseeker/log/httpseeker.log`

```bash
# 实时查看日志
tail -f httpseeker/log/httpseeker.log
```

#### pytest 输出控制

```bash
# 显示详细输出
pytest -v -s httpseeker/testcases/

# 只显示失败用例
pytest -v --tb=short httpseeker/testcases/

# 显示最详细的错误信息
pytest -v --tb=long httpseeker/testcases/
```

---

## 常见问题

### 1. 如何处理动态 Token？

**方法 1: 使用缓存变量**

```yaml
test_steps:
  # 步骤1: 登录获取 token
  - name: "登录"
    case_id: "login_001"
    request:
      method: "POST"
      url: "/api/v1/login"
      body_type: "json"
      body:
        username: "${USERNAME}"
        password: "${PASSWORD}"

    teardown:
      - extract:
          key: "access_token"
          type: "cache"
          jsonpath: "$.json.data.token"

  # 步骤2: 使用 token
  - name: "获取用户信息"
    case_id: "user_001"
    request:
      method: "GET"
      url: "/api/v1/user/profile"
      headers:
        Authorization: "Bearer ${cache.access_token}"
```

**方法 2: 使用全局变量**

```yaml
teardown:
  - extract:
      key: "TOKEN"              # 写入环境变量
      type: "global"
      jsonpath: "$.json.data.token"
```

后续用例可以直接使用 `${TOKEN}`。

### 2. 如何调试失败的用例？

1. **查看日志文件**
   ```bash
   tail -f httpseeker/log/httpseeker.log
   ```

2. **使用 pytest 详细输出**
   ```bash
   pytest -v -s httpseeker/testcases/your_project/test_case.py
   ```

3. **查看 Allure 报告**
   ```bash
   pytest --alluredir=./httpseeker/report/allure_report
   allure serve ./httpseeker/report/allure_report
   ```

4. **开启调试模式**
   在 `httpseeker/core/conf.toml` 中调整日志级别。

### 3. 如何处理文件上传？

```yaml
test_steps:
  - name: "上传文件"
    case_id: "upload_001"

    request:
      method: "POST"
      url: "/api/v1/upload"
      body_type: "form"
      body:
        description: "文件描述"
      files:
        file: "/absolute/path/to/file.pdf"
        # 或上传多个文件
        # files:
        #   - "/path/to/file1.jpg"
        #   - "/path/to/file2.jpg"

    teardown:
      - assert:
          check: "验证上传成功"
          type: "eq"
          value: 200
          jsonpath: "$.status_code"
```

### 4. 如何跳过某些用例？

**方法 1: 使用 is_run**

```yaml
test_steps:
  - name: "临时禁用的用例"
    case_id: "test_001"
    is_run: false        # 跳过此用例
    request:
      # ...
```

**方法 2: 使用 pytest mark**

```yaml
config:
  mark: ["skip"]         # 整个文件跳过

test_steps:
  - name: "用例"
    case_id: "test_001"
    mark: ["skip"]       # 单个用例跳过
```

```bash
# 运行时排除 skip 标记的用例
pytest -m "not skip" httpseeker/testcases/
```

### 5. 如何并发执行测试？

安装 pytest-xdist：

```bash
pip install pytest-xdist
```

并发执行：

```bash
# 使用 4 个进程并发
pytest -n 4 httpseeker/testcases/

# 自动使用 CPU 核心数
pytest -n auto httpseeker/testcases/
```

### 6. 响应数据为空怎么办？

检查以下几点：

1. **环境配置是否正确**
   - 检查 `env` 文件中的 `HOST` 是否正确
   - 检查网络连接

2. **请求参数是否正确**
   - 验证 headers、body 格式
   - 确认 Content-Type 设置

3. **查看详细日志**
   ```bash
   pytest -v -s --log-cli-level=DEBUG
   ```

4. **检查加密配置**
   - 如果接口需要加密，确保 `encryption_enabled: true`
   - 验证 `encryption_key` 是否正确

### 7. JSONPath 提取失败？

**常见错误：**

```yaml
# ❌ 错误：缺少根路径
jsonpath: "data.token"

# ✅ 正确：使用 $ 开头
jsonpath: "$.json.data.token"
```

**可用的根路径：**
- `$.status_code` - 状态码
- `$.json` - JSON 响应体
- `$.headers` - 响应头
- `$.cookies` - Cookies
- `$.text` - 文本响应
- `$.content` - 二进制内容

**复杂路径示例：**
```yaml
# 获取数组第一个元素
jsonpath: "$.json.data[0].id"

# 获取所有元素
jsonpath: "$.json.data[*].name"

# 条件过滤
jsonpath: "$.json.data[?(@.status=='active')].id"
```

### 8. 如何处理 HTTPS 证书错误？

```yaml
config:
  request:
    verify: false        # 禁用 SSL 验证
```

或在 `conf.toml` 中全局配置：

```toml
[request]
verify = false
```

### 9. 测试用例自动生成失败？

确保：

1. **数据文件路径正确**
   ```
   httpseeker/data/test_data/{project}/test_xxx.yaml
   ```

2. **YAML 格式正确**
   - 使用 YAML 验证工具检查语法
   - 确保缩进使用空格（不是 Tab）

3. **运行生成命令**
   ```bash
   python -m httpseeker.cli generate
   ```

### 10. 数据库连接失败？

检查 `httpseeker/core/conf.toml`：

```toml
[mysql]
host = "localhost"
port = 3306
user = "root"
password = "password"
database = "test_db"
charset = "utf8mb4"
```

确保：
- 数据库服务已启动
- 连接信息正确
- 用户有访问权限

---

## 进阶主题

### 1. 自定义请求引擎

框架支持两种请求引擎：

```python
from httpseeker.enums.request.engin import EnginType

# 使用 requests（默认）
send_request.send_request(case_data, request_engin=EnginType.requests)

# 使用 httpx
send_request.send_request(case_data, request_engin=EnginType.httpx)
```

### 2. 扩展断言类型

在 `httpseeker/utils/assert_control.py` 中添加自定义断言逻辑。

### 3. 自定义报告

在 `conftest.py` 中扩展 pytest hooks：

```python
def pytest_html_results_summary(prefix):
    prefix.extend([html.p("自定义报告信息")])
```

### 4. 集成 CI/CD

**Jenkins Pipeline 示例：**

```groovy
pipeline {
    agent any

    stages {
        stage('Checkout') {
            steps {
                git 'https://github.com/your-repo/httpseeker.git'
            }
        }

        stage('Install Dependencies') {
            steps {
                sh 'pip install -r requirements.txt'
            }
        }

        stage('Run Tests') {
            steps {
                sh '''
                    pytest httpseeker/testcases/ \
                    --alluredir=./httpseeker/report/allure_report \
                    --html=./httpseeker/report/html_report/report.html
                '''
            }
        }

        stage('Generate Report') {
            steps {
                allure includeProperties: false,
                       jdk: '',
                       results: [[path: 'httpseeker/report/allure_report']]
            }
        }
    }

    post {
        always {
            publishHTML([
                reportDir: 'httpseeker/report/html_report',
                reportFiles: 'report.html',
                reportName: 'Test Report'
            ])
        }
    }
}
```

**GitHub Actions 示例：**

```yaml
name: API Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        pip install -r requirements.txt

    - name: Run tests
      run: |
        pytest httpseeker/testcases/ \
        --alluredir=./httpseeker/report/allure_report

    - name: Upload Allure Report
      uses: actions/upload-artifact@v2
      with:
        name: allure-report
        path: httpseeker/report/allure_report
```

---

## 总结

HttpSeeker 是一个功能强大、易于使用的接口自动化测试框架。通过本指南，你应该能够：

1. ✅ 理解框架的核心概念和架构
2. ✅ 编写和运行基本的测试用例
3. ✅ 使用各种断言方式验证接口响应
4. ✅ 处理接口依赖和数据提取
5. ✅ 使用高级功能（加密、数据库、钩子等）
6. ✅ 组织和管理测试项目
7. ✅ 集成到 CI/CD 流程

### 学习路径建议

1. **入门阶段**（1-2天）
   - 搭建框架环境
   - 编写第一个测试用例
   - 学习基本的 YAML 配置

2. **进阶阶段**（3-5天）
   - 掌握各种断言方式
   - 学习变量系统和数据提取
   - 理解接口依赖处理

3. **高级阶段**（1-2周）
   - 使用数据库断言
   - 编写钩子函数
   - 处理加密接口
   - 集成 CI/CD

### 获取帮助

- **GitHub Issues**: [提交问题](https://github.com/your-org/httpseeker/issues)
- **文档**: 查看项目 docs 目录
- **示例**: 参考 `httpseeker/data/test_data/` 中的示例用例

### 贡献指南

欢迎贡献代码和文档！请遵循以下步骤：

1. Fork 项目
2. 创建特性分支
3. 提交变更
4. 推送到分支
5. 创建 Pull Request

---

**祝你使用愉快！**
